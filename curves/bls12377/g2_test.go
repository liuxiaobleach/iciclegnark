// Copyright 2024 Ingonyama
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by Ingonyama DO NOT EDIT

//go:build g2

package bls12377

import (
	"fmt"
	"github.com/ingonyama-zk/icicle/v2/wrappers/golang/curves/bls12377/g2"
	"math"
	"math/big"
	"testing"

	"github.com/consensys/gnark-crypto/ecc"
	bls12_377 "github.com/consensys/gnark-crypto/ecc/bls12-377"
	"github.com/consensys/gnark-crypto/ecc/bls12-377/fr"
	"github.com/stretchr/testify/assert"
)

func randG2Jac() (bls12_377.G2Jac, error) {
	var point bls12_377.G2Jac
	var scalar fr.Element

	_, err := scalar.SetRandom()
	if err != nil {
		return point, err
	}

	_, genG2Jac, _, _ := bls12_377.Generators()

	randomBigInt := big.NewInt(1000)

	point.ScalarMultiplication(&genG2Jac, scalar.BigInt(randomBigInt))
	return point, nil
}

func GenerateG2Points(count int) ([]g2.G2Affine, []bls12_377.G2Affine) {
	// Declare a slice of integers
	var points []g2.G2Affine
	var pointsAffine []bls12_377.G2Affine

	// populate the slice
	for i := 0; i < 10; i++ {
		gnarkP, _ := randG2Jac()

		var p g2.G2Affine
		G2PointAffineFromGnarkJac(&gnarkP, &p)

		var gp bls12_377.G2Affine
		gp.FromJacobian(&gnarkP)
		pointsAffine = append(pointsAffine, gp)
		points = append(points, p)
	}

	log2_10 := math.Log2(10)
	log2Count := math.Log2(float64(count))
	log2Size := int(math.Ceil(log2Count - log2_10))

	for i := 0; i < log2Size; i++ {
		pointsAffine = append(pointsAffine, pointsAffine...)
		points = append(points, points...)
	}

	return points[:count], pointsAffine[:count]
}

func TestToGnarkJacG2(t *testing.T) {
	gnark, _ := randG2Jac()

	var pointAffine g2.G2Affine
	G2PointAffineFromGnarkJac(&gnark, &pointAffine)

	var pointProjective g2.G2Projective
	pointProjective.FromAffine(pointAffine)

	fmt.Printf("%+v\n", pointProjective)
	backToGnark := G2PointToGnarkJac(&pointProjective)

	assert.True(t, gnark.Equal(backToGnark))
}

func TestMsmG2(t *testing.T) {
	for _, v := range []int{24} {
		count := 1 << v
		_, gnarkPoints := GenerateG2Points(count)
		fmt.Print("Finished generating points\n")
		_, gnarkScalars := GenerateScalars(count, false)
		fmt.Print("Finished generating scalars\n")

		res, e := G2MsmOnDevice(gnarkPoints, gnarkScalars)
		assert.Equal(t, e, nil, "error should be nil")

		var AffineLib bls12_377.G2Affine

		gResult, _ := AffineLib.MultiExp(gnarkPoints, gnarkScalars, ecc.MultiExpConfig{})

		assert.True(t, gResult.Equal(res))
	}
}
