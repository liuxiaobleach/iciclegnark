// Copyright 2023 Ingonyama
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by Ingonyama DO NOT EDIT

package bw6761

import (
	"bufio"
	"fmt"
	"math"
	"math/big"
	"os"
	"testing"
	"time"

	"github.com/consensys/gnark-crypto/ecc"
	bw6_761 "github.com/consensys/gnark-crypto/ecc/bw6-761"
	"github.com/consensys/gnark-crypto/ecc/bw6-761/fp"
	"github.com/consensys/gnark-crypto/ecc/bw6-761/fr"
	core "github.com/ingonyama-zk/icicle/v2/wrappers/golang/core"
	icicle_bw6_761 "github.com/ingonyama-zk/icicle/v2/wrappers/golang/curves/bw6761"
	"github.com/stretchr/testify/assert"
)

func randG1Jac() (bw6_761.G1Jac, error) {
	var point bw6_761.G1Jac
	var scalar fr.Element

	_, err := scalar.SetRandom()
	if err != nil {
		return point, err
	}

	genG1Jac, _, _, _ := bw6_761.Generators()

	//randomBigInt, err := rand.Int(rand.Reader, new(big.Int).Lsh(big.NewInt(1), 63))
	//randomBigInt, err := rand.Int(rand.Reader, big.NewInt(100))
	randomBigInt := big.NewInt(100)

	point.ScalarMultiplication(&genG1Jac, scalar.BigInt(randomBigInt))
	return point, nil
}

func GeneratePoints(count int) ([]icicle_bw6_761.Affine, []bw6_761.G1Affine) {
	// Declare a slice of integers
	var points []icicle_bw6_761.Affine
	var pointsAffine []bw6_761.G1Affine

	// populate the slice
	for i := 0; i < 10; i++ {
		gnarkP, _ := randG1Jac()
		var pointAffine bw6_761.G1Affine
		pointAffine.FromJacobian(&gnarkP)

		var p icicle_bw6_761.Projective
		G1ProjectivePointFromJacGnark(&p, &gnarkP)

		pointsAffine = append(pointsAffine, pointAffine)
		points = append(points, *StripZ(&p))
	}

	log2_10 := math.Log2(10)
	log2Count := math.Log2(float64(count))
	log2Size := int(math.Ceil(log2Count - log2_10))

	for i := 0; i < log2Size; i++ {
		pointsAffine = append(pointsAffine, pointsAffine...)
		points = append(points, points...)
	}

	return points[:count], pointsAffine[:count]
}

func ReadGnarkPointsFromFile(filePath string, size int) (points []icicle_bw6_761.Affine, gnarkPoints []bw6_761.G1Affine) {
	points = make([]icicle_bw6_761.Affine, size)
	gnarkPoints = make([]bw6_761.G1Affine, size)
	file, _ := os.Open(filePath)
	scanner := bufio.NewScanner(file)

	for i := 0; scanner.Scan(); i++ {
		gnarkPoints[i].X.SetString(scanner.Text())
		scanner.Scan()
		gnarkPoints[i].Y.SetString(scanner.Text())

		var p icicle_bw6_761.Projective
		FromG1AffineGnark(&gnarkPoints[i], &p)

		points[i] = *StripZ(&p)

	}
	return
}

func GeneratePointsProj(count int) ([]icicle_bw6_761.Projective, []bw6_761.G1Jac) {
	// Declare a slice of integers
	var points []icicle_bw6_761.Projective
	var pointsAffine []bw6_761.G1Jac

	// Use a loop to populate the slice
	for i := 0; i < count; i++ {
		gnarkP, _ := randG1Jac()

		var p icicle_bw6_761.Projective
		G1ProjectivePointFromJacGnark(&p, &gnarkP)

		pointsAffine = append(pointsAffine, gnarkP)
		points = append(points, p)
	}

	return points, pointsAffine
}

func GenerateScalars(count int, skewed bool) ([]icicle_bw6_761.ScalarField, []fr.Element) {
	// Declare a slice of integers
	var scalars []icicle_bw6_761.ScalarField
	var scalars_fr []fr.Element

	var rand fr.Element
	var zero fr.Element
	zero.SetZero()
	var one fr.Element
	one.SetOne()
	var randLarge fr.Element
	randLarge.SetRandom()

	if skewed && count > 1_200_000 {
		for i := 0; i < count-1_200_000; i++ {
			rand.SetRandom()
			s := NewFieldFromFrGnark(rand)

			scalars_fr = append(scalars_fr, rand)
			scalars = append(scalars, *s)
		}

		for i := 0; i < 600_000; i++ {
			s := NewFieldFromFrGnark(randLarge)

			scalars_fr = append(scalars_fr, randLarge)
			scalars = append(scalars, *s)
		}
		for i := 0; i < 400_000; i++ {
			s := NewFieldFromFrGnark(zero)

			scalars_fr = append(scalars_fr, zero)
			scalars = append(scalars, *s)
		}
		for i := 0; i < 200_000; i++ {
			s := NewFieldFromFrGnark(one)

			scalars_fr = append(scalars_fr, one)
			scalars = append(scalars, *s)
		}
	} else {
		for i := 0; i < count; i++ {
			rand.SetRandom()
			s := NewFieldFromFrGnark(rand)

			scalars_fr = append(scalars_fr, rand)
			scalars = append(scalars, *s)
		}
	}

	return scalars[:count], scalars_fr[:count]
}

func ReadGnarkScalarsFromFile(filePath string, size int) (scalars []icicle_bw6_761.ScalarField, gnarkScalars []fr.Element) {
	scalars = make([]icicle_bw6_761.ScalarField, size)
	gnarkScalars = make([]fr.Element, size)
	file, _ := os.Open(filePath)
	scanner := bufio.NewScanner(file)
	for i := 0; scanner.Scan(); i++ {
		gnarkScalars[i].SetString(scanner.Text())
		scalars[i] = *NewFieldFromFrGnark(gnarkScalars[i])
	}
	return
}

func TestFieldFromGnark(t *testing.T) {
	var rand fr.Element
	rand.SetRandom()

	f := NewFieldFromFrGnark(rand)
	element_bits := rand.Bits()
	assert.Equal(t, f.GetLimbs(), core.ConvertUint64ArrToUint32Arr(element_bits[:]))
}

func BenchmarkBatchConvertFromFrGnarkThreaded(b *testing.B) {
	// ROUTINES := []int{4,5,6,7,8}

	// for _, routineAmount := range ROUTINES {
	routineAmount := 7
	_, scalars_fr := GenerateScalars(1<<24, false)
	b.Run(fmt.Sprintf("Convert %d", routineAmount), func(b *testing.B) {
		for n := 0; n < b.N; n++ {
			_ = BatchConvertFromFrGnarkThreaded(scalars_fr, routineAmount)
		}
	})
	// }
}

func BenchmarkBatchConvertFromFrGnark(b *testing.B) {
	_, scalars_fr := GenerateScalars(1<<24, false)
	b.Run("BatchConvert 2^24", func(b *testing.B) {
		for n := 0; n < b.N; n++ {
			_ = BatchConvertFromFrGnark(scalars_fr)
		}
	})
}

func TestPointFromGnark(t *testing.T) {
	gnarkP, _ := randG1Jac()

	var f icicle_bw6_761.BaseField
	f.One()
	var p icicle_bw6_761.Projective
	G1ProjectivePointFromJacGnark(&p, &gnarkP)

	z_inv := new(fp.Element)
	z_invsq := new(fp.Element)
	z_invq3 := new(fp.Element)
	x := new(fp.Element)
	y := new(fp.Element)

	z_inv.Inverse(&gnarkP.Z)
	z_invsq.Mul(z_inv, z_inv)
	z_invq3.Mul(z_invsq, z_inv)

	x.Mul(&gnarkP.X, z_invsq)
	y.Mul(&gnarkP.Y, z_invq3)

	assert.Equal(t, p.X, *NewFieldFromFpGnark(*x))
	assert.Equal(t, p.Y, *NewFieldFromFpGnark(*y))
	assert.Equal(t, p.Z, f)
}

func TestPointAffineNoInfinityToProjective(t *testing.T) {
	gnarkP, _ := randG1Jac()
	var f icicle_bw6_761.BaseField
	var p icicle_bw6_761.Projective

	f.One()
	affine := StripZ(G1ProjectivePointFromJacGnark(&p, &gnarkP))
	proj := affine.ToProjective()

	assert.Equal(t, proj.X, affine.X)
	assert.Equal(t, proj.X, affine.X)
	assert.Equal(t, proj.Z, f)
}

func TestToGnarkAffine(t *testing.T) {
	gJac, _ := randG1Jac()
	var proj icicle_bw6_761.Projective
	G1ProjectivePointFromJacGnark(&proj, &gJac)

	var gAffine bw6_761.G1Affine
	gAffine.FromJacobian(&gJac)

	affine := ProjectiveToGnarkAffine(&proj)
	assert.Equal(t, *affine, gAffine)
}

func TestMSM(t *testing.T) {
	for _, v := range []int{24} {
		count := 1 << v

		_, gnarkPoints := GeneratePoints(count)
		fmt.Print("Finished generating points\n")
		_, gnarkScalars := GenerateScalars(count, true)
		fmt.Print("Finished generating scalars\n")

		startTime := time.Now()
		res, e := MsmOnDevice(gnarkPoints, gnarkScalars) // non mont
		fmt.Printf("icicle MSM took: %d ms\n", time.Since(startTime).Milliseconds())

		assert.Equal(t, e, nil, "error should be nil")
		fmt.Print("Finished icicle MSM\n")

		var AffineLib bw6_761.G1Affine

		gResult, _ := AffineLib.MultiExp(gnarkPoints, gnarkScalars, ecc.MultiExpConfig{})
		fmt.Print("Finished Gnark MSM\n")

		assert.True(t, gResult.Equal(res))
	}
}
